zabbix_export:
  version: '7.0'
  media_types:
    -
      name: 'Event-Driven Ansible'
      type: WEBHOOK
      parameters:
        -
          name: acknowledged
          value: '{EVENT.ACK.STATUS}'
        -
          name: endpoint
          value: /endpoint
        -
          name: event_date
          value: '{EVENT.DATE}'
        -
          name: event_id
          value: '{EVENT.ID}'
        -
          name: event_name
          value: '{EVENT.NAME}'
        -
          name: event_nseverity
          value: '{EVENT.NSEVERITY}'
        -
          name: event_object
          value: '{EVENT.OBJECT}'
        -
          name: event_severity
          value: '{EVENT.SEVERITY}'
        -
          name: event_source
          value: '{EVENT.SOURCE}'
        -
          name: event_tags
          value: '{EVENT.TAGSJSON}'
        -
          name: event_time
          value: '{EVENT.TIME}'
        -
          name: event_value
          value: '{EVENT.VALUE}'
        -
          name: host_groups
          value: '{TRIGGER.HOSTGROUP.NAME}'
        -
          name: host_host
          value: '{HOST.HOST}'
        -
          name: host_id
          value: '{HOST.ID}'
        -
          name: host_ip
          value: '{HOST.IP}'
        -
          name: host_port
          value: '{HOST.PORT}'
        -
          name: message
          value: '{ALERT.MESSAGE}'
        -
          name: monitoring_source
          value: 'Zabbix sever'
        -
          name: operation_data
          value: '{EVENT.OPDATA}'
        -
          name: send_to
          value: '{ALERT.SENDTO}'
        -
          name: subject
          value: '{ALERT.SUBJECT}'
        -
          name: trigger_description
          value: '{TRIGGER.DESCRIPTION}'
        -
          name: trigger_id
          value: '{TRIGGER.ID}'
        -
          name: trigger_name
          value: '{TRIGGER.NAME}'
      script: |
        var Eda = {
            params: [],
        
            setParams: function (params) {
                if (typeof params !== 'object') {
                    Zabbix.log(3, '[ Event-Driven Ansible webhook ] Incorrect type of "params" parameter given. Must be object. Given: ' + (typeof params));
                    throw 'Incorrect type of "params" parameter given. Check server log for more information';
                }
                Eda.params = params;
            },
        
            sendMessage: function () {
                var response, request = new HttpRequest()
                var url = Eda.params['send_to'] + Eda.params['endpoint'];
                var data = JSON.stringify(Eda.params);
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] URL: ' + url);
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] params: ' + data);
                
                request.addHeader('Content-Type: application/json');
                response = request.post(url, data);
                
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] HTTP code: ' + request.getStatus());
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] Response: ' + response);
        
                if (request.getStatus() !== 200) {
                    if (typeof response.description === 'string') {
                        Zabbix.log(3, '[ Event-Driven Ansible webhook ] notification failed: ' + response.description);
                        throw response.description;
                    }
                    else {
                        Zabbix.log(3, '[ Event-Driven Ansible webhook ] notification failed: ' + response.description);
                        throw 'Unknown error. Check debug log for more information';
                    }
                }
            }
        };
        
        /**
        * Function for transform string date and time to timestamp
        * @param    {String} strDate    Date of events
        * @param    {String} strTime    Time of events
        * @return   {Number}            Timestamp of events
        */
        function toTimestamp(strDate, strTime){
            var EventDate = strDate.split(".");
            var EventTime = strTime.split(":");
            var newDate = new Date(EventDate[0], EventDate[1] - 1, EventDate[2],
                EventTime[0], EventTime[1], EventTime[2])
            return newDate.getTime()/1000;
        }
        
        /**
        * Function for transform string with hostgroups to list
        * @param    {String} hostgroups Comma separated list of groups as a string
        * @return   {List}              List of hostgroups
        */
        function prepareHostgroups(hostgroups) {
            var host_groups = []; 
            var groups = hostgroups.split(',');
            for (i = 0; i < groups.length; i++) {
                host_groups.push(groups[i].trim())
            }
            return host_groups;
        }
        
        /**
        * Function for transform tags
        * @param    {String} event_tags Input event tags
        * @return   {Object}            Tags in format: {'tag_name': ['tag_value']}
        */
        function transformTags(event_tags) {
            var tags = {};
            var input_tags = JSON.parse(event_tags);
            for (i = 0; i < input_tags.length; i++) {
                if (input_tags[i]['tag'] in tags) {
                    tags[input_tags[i]['tag']].push(input_tags[i]['value'])
                } else {
                    tags[input_tags[i]['tag']] = [input_tags[i]['value']]
                }
            }
            return tags;
        }
        
        /**
        * Function for check destination params
        * @param    {String} target Input data of destination
        * @return   {Boolean}       Result
        */
        function checkDestination(target) {
            if (!target.includes(':')) {
                return false;
            }
            var address = target.split(':');
            if (address.length == 2) {
                var ip = address[0].split('.');
                if (ip.length == 4) {
                    for (i = 0; i < ip.length; i++) {
                        if (Number(ip[i]) > 255 || isNaN(ip[i]) || ip[i].length == 0) {
                            return false;
                        }
                    }
                    if (Number(address[1]) > 65535 || isNaN(address[1]) || address[1].length == 0) {
                        return false;
                    }
                    return true;
                }
            }
            return false;
        }
        
        
        try {
            var params = JSON.parse(value);
            var fields = {};
            Zabbix.log(4, '[ Event-Driven Ansible webhook ] Executed with params: ' + value);
        
            // Possible values: 0 - Trigger
            if (params.event_source != 0) {
                throw 'Incorrect "event_source" parameter given: ' + params.event_source + '\nMust be 0';
            }
        
            // Check trigger update and trigger resolve events
            if (params.event_source == 0 && params.event_value != 1) {
                throw 'Incorrect "event_value" parameter given: "' + params.event_value + '".\nMust be 1. Trigger events of updating and resolving are unsupported';
            }
        
            // Check destination
            if (!checkDestination(params.send_to)) {
                throw 'Incorrect media type parameter given: ' + params.send_to + '\nMust be IP:PORT';
            }
        
            // target params
            fields['send_to'] = params.send_to;
            fields['endpoint'] = params.endpoint;
            
            // Event params
            fields['event_id'] = parseInt(params.event_id);
            fields['event_source'] = parseInt(params.event_source); 
            fields['event_object'] = parseInt(params.event_object);
            fields['event_datetime'] = {
                'event_date': params.event_date,
                'event_time': params.event_time,
                'event_datetime_timestamp': toTimestamp(params.event_date, params.event_time)
            }
            
            // Other params
            fields['monitoring_source'] = params.monitoring_source;
            fields['subject'] = params.subject;
        
            // Try to parse Json in message
            try {
                fields['message'] = JSON.parse(params.message)
            }
            catch (error) {
                fields['message'] = params.message;
            }
                
            // Host params
            fields['host_groups'] = prepareHostgroups(params.host_groups);
            fields['host_id'] = parseInt(params.host_id);
            fields['host_port'] = parseInt(params.host_port);
            fields['host_ip'] = params.host_ip;
            fields['host_name'] = params.host_host;
        
            // Event params
            fields['event_tags'] = transformTags(params.event_tags);
            fields['event_nseverity'] = parseInt(params.event_nseverity);
            fields['acknowledged'] = params.acknowledged;
            fields['operation_data'] = params.operation_data;
            fields['event_severity'] = params.event_severity;
            fields['event_name'] = params.event_name; 
            fields['event_value'] = parseInt(params.event_value);
            
            // Trigger params
            fields['trigger_id'] = parseInt(params.trigger_id);
            fields['trigger_name'] = params.trigger_name;
            fields['trigger_description'] = params.trigger_description;
            
            Eda.setParams(fields);
            Eda.sendMessage();
            return true;
        }
        catch (error) {
            Zabbix.log(3, '[ Event-Driven Ansible webhook ] notification failed: ' + error);
            throw 'Sending failed: ' + error + '.';
        }
      message_templates:
        -
          event_source: TRIGGERS
          operation_mode: PROBLEM
          subject: 'Event ID: {EVENT.ID}, Host: {HOST.NAME}, Problem: {EVENT.NAME}'
