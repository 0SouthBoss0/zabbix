zabbix_export:
  version: '7.0'
  media_types:
    -
      name: 'Event-Driven Ansible'
      type: WEBHOOK
      parameters:
        -
          name: acknowledged
          value: '{EVENT.ACK.STATUS}'
        -
          name: endpoint
          value: /endpoint
        -
          name: event_date
          value: '{EVENT.DATE}'
        -
          name: event_id
          value: '{EVENT.ID}'
        -
          name: event_name
          value: '{EVENT.NAME}'
        -
          name: event_nseverity
          value: '{EVENT.NSEVERITY}'
        -
          name: event_object
          value: '{EVENT.OBJECT}'
        -
          name: event_severity
          value: '{EVENT.SEVERITY}'
        -
          name: event_source
          value: '{EVENT.SOURCE}'
        -
          name: event_tags
          value: '{EVENT.TAGSJSON}'
        -
          name: event_time
          value: '{EVENT.TIME}'
        -
          name: event_value
          value: '{EVENT.VALUE}'
        -
          name: host_groups
          value: '{TRIGGER.HOSTGROUP.NAME}'
        -
          name: host_host
          value: '{HOST.HOST}'
        -
          name: host_id
          value: '{HOST.ID}'
        -
          name: host_ip
          value: '{HOST.IP}'
        -
          name: host_port
          value: '{HOST.PORT}'
        -
          name: HTTPProxy
        -
          name: monitoring_source
          value: 'Zabbix sever'
        -
          name: operation_data
          value: '{EVENT.OPDATA}'
        -
          name: send_to
          value: '{ALERT.SENDTO}'
        -
          name: subject
          value: '{ALERT.SUBJECT}'
        -
          name: trigger_description
          value: '{TRIGGER.DESCRIPTION}'
        -
          name: trigger_id
          value: '{TRIGGER.ID}'
        -
          name: trigger_name
          value: '{TRIGGER.NAME}'
      script: |
        var Eda = {
            params: {},
        
            setParams: function (params) {
                var required_params = [
                        'send_to',
                        'event_source',
                        'event_value',
                        'event_date',
                        'event_time'],
                    integer_fields = [
                        'event_id',
                        'event_nseverity',
                        'event_object',
                        'event_source',
                        'event_value',
                        'host_id',
                        'trigger_id']
        
                required_params.forEach(function (field) {
                    if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                        throw 'Required param is not set: "' + field + '".';
                    }
                });
        
                Eda.params = params;
        
                Object.keys(Eda.params)
                    .forEach(function (key) {
                        if (integer_fields.indexOf(key) !== -1) {
                            if (isNaN(Eda.params[key])) {
                                throw 'Parameter "' + key + '" must be integer. Given value: ' + Eda.params[key];
                            }
                            Eda.params[key] = parseInt(Eda.params[key]);
                        }
                    });
        
                // Check type of event. Possible values: 0 - Trigger
                if (params.event_source != 0) {
                    throw 'Incorrect "event_source" parameter given: ' + params.event_source + '\nMust be 0';
                }
        
                // Check trigger update and trigger resolve events
                if (params.event_source == 0 && params.event_value != 1) {
                    throw ('Incorrect "event_value" parameter given: "' + params.event_value 
                        + '".\nMust be 1. Trigger events of updating and resolving are unsupported');
                }
                
                // Check endpoint
                Eda.params.endpoint = (Eda.params.endpoint.startsWith('/'))
                        ? Eda.params.endpoint : '/' + Eda.params.endpoint;
                // Prepare groups
                Eda.params.host_groups = Eda.params.hasOwnProperty('host_groups') 
                        ? this.prepareHostgroups(Eda.params.host_groups): []
                // Prepare tags
                Eda.params.event_tags = params.hasOwnProperty('event_tags') 
                        ? this.transformTags(Eda.params.event_tags): {}
                // Prepare timestamp
                Eda.params.event_datetime_timestamp = this.getTimestamp(
                    Eda.params.event_date, Eda.params.event_time)
            },
        
            setProxy: function (HTTPProxy) {
                Eda.HTTPProxy = HTTPProxy;
            },
        
            prepareHostgroups: function (hostgroups) {
                var host_groups = []; 
                var groups = hostgroups.split(',');
                for (i = 0; i < groups.length; i++) {
                    if (groups[i].trim().length > 0) {
                        host_groups.push(groups[i].trim())
                    }
                }
                return host_groups;
            },
        
            getTimestamp: function (strDate, strTime) {
                var EventDate = strDate.split(".");
                var EventTime = strTime.split(":");
                
                try {
                    var newDate = new Date(EventDate[0], EventDate[1] - 1, EventDate[2],
                        EventTime[0], EventTime[1], EventTime[2])
                    if (newDate == 'Invalid Date') {
                        throw ('Incorrect event_date and event_time parameter given. event_date: ' +
                            strDate + ' event_time: ' + strTime);
                    }
                } catch (error) {
                    throw ('Incorrect event_date and event_time parameter given. event_date: ' +
                        strDate + ' event_time: ' + strTime);
                }
        
                return newDate.getTime()/1000;
            },
        
            transformTags: function (event_tags) {
                var tags = {};
                if (event_tags.length == 0) {
                    return {};
                }
        
                try {
                    var input_tags = JSON.parse(event_tags);
                } catch (error) {
                    throw 'Incorrect event_tags parameter given: ' + event_tags + '\nMust be in JSON';
                }
                
                if (!Array.isArray(input_tags)) {
                    throw 'Incorrect event_tags parameter given: ' + event_tags + '\nMust be array';
                }
        
                for (i = 0; i < input_tags.length; i++) {
                    var obj = input_tags[i];
                    if (typeof obj === 'object' && obj.hasOwnProperty('tag') && obj.hasOwnProperty('value')) {
                        if (obj['tag'] in tags) {
                            tags[obj['tag']].push(obj['value'])
                        } else {
                            tags[obj['tag']] = [obj['value']]
                        }
                    } else {
                        throw 'Incorrect event_tags structure given: ' + event_tags + '\nMust contain "tag" and "value"';
                    }
                }
                return tags;
            },
        
            sendMessage: function () {
                var response, request = new HttpRequest();
                var url = Eda.params['send_to'] + Eda.params['endpoint'];
                var data = JSON.stringify(Eda.params);
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] URL: ' + url);
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] params: ' + data);
                
                if (typeof Eda.HTTPProxy !== 'undefined' && Eda.HTTPProxy !== '') {
                    request.setProxy(Eda.HTTPProxy);
                }
                request.addHeader('Content-Type: application/json');
                response = request.post(url, data);
                
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] HTTP code: ' + request.getStatus());
                Zabbix.log(4, '[ Event-Driven Ansible webhook ] Response: ' + response);
        
                if (request.getStatus() !== 200) {
                    throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                }
            }
        };
        
        
        try {
            var params = JSON.parse(value);
            Zabbix.log(4, '[ Event-Driven Ansible webhook ] Executed with params: ' + value);
            
            Eda.setParams(params);
            Eda.setProxy(params.HTTPProxy);
            Eda.sendMessage();
            return true;
        }
        catch (error) {
            Zabbix.log(3, '[ Event-Driven Ansible webhook ] notification failed: ' + error);
            throw 'Sending failed: ' + error;
        }
      message_templates:
        -
          event_source: TRIGGERS
          operation_mode: PROBLEM
          subject: 'Event ID: {EVENT.ID}, Host: {HOST.HOST}, Problem: {EVENT.NAME}'
